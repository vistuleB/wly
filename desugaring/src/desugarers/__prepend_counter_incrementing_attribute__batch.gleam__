import gleam/dict.{type Dict}
import gleam/list
import gleam/option
import infrastructure.{
  type Desugarer,
  type DesugarerTransform,
  type DesugaringError,
  type TrafficLight,
  Desugarer,
  Continue,
} as infra
import nodemaps_2_desugarer_transforms as n2t
import vxml.{type VXML, type Attribute, Attribute, V}
import blame as bl

fn nodemap(
  vxml: VXML,
  inner: InnerParam,
) -> #(VXML, TrafficLight) {
  case vxml {
    V(_, tag, attrs, _) -> {
      case dict.get(inner, tag) {
        Ok(#(new, traffic_light)) -> #(V(..vxml, attributes: [new, ..attrs]), traffic_light)
        _ -> #(vxml, Continue)
      }
    }
    _ -> #(vxml, Continue)
  }
}

fn nodemap_factory(inner: InnerParam) -> n2t.EarlyReturnOneToOneNoErrorNodeMap {
  nodemap(_, inner)
}

fn transform_factory(inner: InnerParam) -> DesugarerTransform {
  nodemap_factory(inner)
  |> n2t.early_return_one_to_one_no_error_nodemap_2_desugarer_transform
}

fn param_to_inner_param(param: Param) -> Result(InnerParam, DesugaringError) {
  param
  |> list.map(fn(triple) { 
    #(
      triple.0, 
      #(Attribute(desugarer_blame(45), ".", triple.1 <> " ::++" <> triple.1), triple.2)
    ) 
  })
  |> infra.dict_from_list_with_desugaring_error
}

type Param = List(#(String, String,  TrafficLight))
//                  ↖       ↖        ↖
//                  tag     counter  traffic_light
//                          name
type InnerParam = Dict(String, #(Attribute, TrafficLight))
fn desugarer_blame(line_no: Int) { bl.Des([], name, line_no) }

pub const name = "prepend_counter_incrementing_attribute__batch"

// 🏖️🏖️🏖️🏖️🏖️🏖️🏖️🏖️🏖️🏖️🏖️
// 🏖️🏖️ Desugarer 🏖️🏖️
// 🏖️🏖️🏖️🏖️🏖️🏖️🏖️🏖️🏖️🏖️🏖️
//------------------------------------------------53
/// For each #(tag, counter_name, traffic_light) 
/// tuple in the parameter list, this desugarer adds 
/// an attribute of the form
/// ```
/// .=counter_name ::++counter_name
/// ```
/// to each node of tag 'tag', where the key is a 
/// period '.' and the value is the string 
/// '<counter_name> ::++<counter_name>'. As counters
/// are evaluated and substitued also inside of 
/// key-value pairs, adding this key-value pair 
/// causes the counter <counter_name> to increment at
/// each occurrence of a node of tag 'tag'.
pub fn constructor(
  param: Param,
) -> Desugarer {
  Desugarer(
    name: name,
    stringified_param: option.Some(param |> infra.list_param_stringifier),
    stringified_outside: option.None,
    transform: case param_to_inner_param(param) {
      Error(error) -> fn(_) { Error(error) }
      Ok(inner) -> transform_factory(inner)
    },
  )
}

// 🌊🌊🌊🌊🌊🌊🌊🌊🌊🌊🌊🌊
// 🌊🌊🌊 tests 🌊🌊🌊🌊🌊
// 🌊🌊🌊🌊🌊🌊🌊🌊🌊🌊🌊🌊
fn assertive_tests_data() -> List(infra.AssertiveTestData(Param)) {
  []
}

pub fn assertive_tests() {
  infra.assertive_test_collection_from_data(name, assertive_tests_data(), constructor)
}
